---
title: >-
  Building and publishing .NET Core Micro-services to Kubernetes using Azure
  DevOps
category: Web development
datePublished: '2019-11-15'
dateCreated: '2019-11-13'
---
<p>The last week I spend quite a bit of time figuring out the best way to deploy micro-services on Kubernetes with Azure DevOps. At first it felt quite hard, because there are so many tools involved. But with the right tools I got it working within an hour, which as a pleasant surprise!</p><p>In this post I'll talk you through the steps that I took to build and publish a .NET Core micro service to Azure Kubernetes Service from an Azure DevOps pipeline. We'll cover the following topics:</p><ul><li><a href="#packaging-a-net-core-micro-service">Packaging a .NET Core micro-service</a></li><li><a href="#setting-up-a-build-pipeline">Setting up a build pipeline</a></li><li><a href="#setting-up-a-release-pipeline">Setting up a release pipeline</a></li></ul><p>Before we dive in, let's take a short look at the technical requirements for this post.</p><h2 id="technical-requirements">Technical requirements</h2><p>For the purpose of this post, I'm going to assume that you have the following tools on your machine:</p><ul><li><a href="https://www.docker.com/products/docker-desktop">Docker Desktop</a></li><li><a href="https://dotnet.microsoft.com/">.NET Core SDK 3.0/2.2</a></li><li><a href="https://code.visualstudio.com/">Visual Studio Code</a> or a similar editor</li><li><a href="https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest">Azure CLI 2.0</a></li><li><a href="https://git-scm.com/">GIT</a></li></ul><p>In addition to this you'll need to have access to the following resources:</p><ul><li>An active Azure Subscription (This can be a trial)</li><li>An active Azure DevOps project</li></ul><p>I'm assuming that you are somewhat familiar with the different concepts of Kubernetes. In case you want a good introduction to Kubernetes, check out this blogpost by Bruno Krebs: <a href="https://auth0.com/blog/kubernetes-tutorial-step-by-step-introduction-to-basic-concepts/">https://auth0.com/blog/kubernetes-tutorial-step-by-step-introduction-to-basic-concepts/</a>.</p><p>Let's start with a simple micro-service and package it.</p><h2 id="packaging-a-net-core-micro-service">Packaging a .NET Core micro-service</h2><p>When you have a ASP.NET Core web application that you want to deploy it to kubernetes as a micro-service, you'll need to package it as a container image first.</p><p>Let's create a sample application and package it as a docker container image. We need to perform the following steps to do  this:</p><ol><li><a href="#create-a-new-asp-net-core-web-application">Create a new ASP.NET Core web application</a></li><li><a href="#create-a-dockerfile-for-the-application">Create a Dockerfile for the application</a></li><li><a href="#build-the-image-locally-to-test-it">Build the image locally to test it</a></li></ol><p>Let's get started.</p><h3 id="create-a-new-asp-net-core-web-application">Create a new ASP.NET Core web application</h3><p>First, we're going to create a new ASP.NET Core web application. I'll be using ASP.NET Core 3.0, but the steps we're going to take here will also work for older versions of ASP.NET Core.</p><p>Execute the following commands in a terminal inside an empty folder:</p><figure class="kg-card kg-code-card"><pre><code>dotnet new sln -n MyMicroservice
dotnet new web -o src/MyMicroservice
dotnet sln add src/MyMicroservice
</code></pre><figcaption>Steps required to create a new web application</figcaption></figure><p>The following actions are executed:</p><ol><li>First, we create a new solution file.</li><li>Next, we create a new web application in src/MyMicroservice.</li><li>Finally, we add the web project to the solution file.</li></ol><p>After creating the project it's a good practice to commit your changes to GIT.</p><p>Create a new file <code>.gitignore</code> in the root of your project, and add the following contents to it:</p><pre><code>bin/
obj/

.vs/
.idea/
.ionide/</code></pre><p>After configuring the ignore rules for GIT, use the following commands to convert the working folder to a GIT repo:</p><pre><code>git init
git add .
git commit -m "Initial commit"</code></pre><p>Now that we have the web application set up, let's take a look at packaging it as a docker container image.</p><h3 id="create-a-dockerfile-for-the-application">Create a Dockerfile for the application</h3><p>There are many ways in which you can approach the process of containerizing a .NET Core application. </p><p>I personally like to build a multi-stage docker build. In a multi-stage docker build you define multiple images in one docker file. The first stage, will build the app and produce the deliverables inside an image. The second stage copies the deliverables from the first stage into a new image.</p><p>Using multiple stages allows me to import secrets into the first stage without having to publish them to my production environment. We're only publishing the second stage, which doesn't contain any unwanted files, such as secrets, from the first stage.</p><p>To create a multi-stage Dockerfile for our micro-service we need to add a new Dockerfile to the root of the solution, in the same folder as the <code>MyMicroservice.sln</code> file. </p><p>Add the following contents to this file:</p><figure class="kg-card kg-code-card"><pre><code>FROM mcr.microsoft.com/dotnet/core/sdk:3.0 AS build

WORKDIR /repo

COPY MyMicroservice.sln .
COPY src/MyMicroservice/MyMicroservice.csproj ./src/MyMicroservice/MyMicroservice.csproj

RUN dotnet restore

COPY . ./

RUN dotnet publish ./src/MyMicroservice/MyMicroservice.csproj -c Release -o /app/

FROM mcr.microsoft.com/dotnet/core/aspnet:3.0 AS runtime

COPY --from=build /app/ /app/
WORKDIR /app

ENTRYPOINT ["dotnet", "MyMicroservice.dll"]
</code></pre><figcaption>Multi-stage Dockerfile</figcaption></figure><p>Let's go over the contents of the Dockerfile, step-by-step.</p><ol><li>First, we define a new image that is based on the .NET Core SDK image and give it the alias <code>build</code>. This alias we'll use later to copy files from this new image.</li><li>Next, we copy the solution file and project files. We run <code>dotnet restore</code> after copying these files to get the dependencies. Doing so, allows us to cache the nuget packages we need for later builds.</li><li>After that, we copy the rest of the project files and run <code>dotnet publish</code> on the web project to produce the artifacts we need for production.</li><li>Then, we create a second stage. This stage is based on the ASP.NET Core runtime image. We give it the alias runtime.</li><li>Next, we copy the deliverables produced in the build stage to the runtime stage. Notice that it doesn't include any source files that may contain nuget secrets and other stuff that we might need.</li><li>Finally, we set  the working folder and the entrypoint so that we can run the web application from the container.</li></ol><p>With the Dockerfile in place we can build the image locally to test whether it will build correctly.</p><h3 id="build-the-image-locally-to-test-it">Build the image locally to test it</h3><p>To build a docker image on your local machine, use the following command:</p><figure class="kg-card kg-code-card"><pre><code class="language-shell">docker build -t mymicroservice:1 .</code></pre><figcaption>Command to build the docker image</figcaption></figure><p>This will build the stages in the order as they appear in the docker file. The final stage is then tagged as <code>mymicroservice</code> and ready to run.</p><p>You can run the docker image as a container using the following command:</p><figure class="kg-card kg-code-card"><pre><code>docker run -p -d 80:8080 mymicroservice:1</code></pre><figcaption>Command to run a container using our docker image</figcaption></figure><p>Now that we have the application package, let's set up a build pipeline to execute the build commands automatically when we push sources to Azure DevOps.</p><h2 id="setting-up-a-build-pipeline">Setting up a build pipeline</h2><p>To build your .NET Micro-service on Azure DevOps, you'll need a DevOps organization and project on <a href="https://dev.azure.com">https://dev.azure.com</a>. So if you haven't got one, go there and create yourself a new DevOps project. </p><p>I'm also going to assume you have access to an Azure subscription. You'll need it to setup Azure Container Registry and </p><p><strong>Note:</strong> Azure DevOps is free to use if you're working on a public project or only have a few people working on your project! So there's really no reason not to give it a shot!</p><p>We're going to perform the following steps to push the code to Azure DevOps and run an automated build:</p><ol><li><a href="#create-a-new-azure-container-registry-instance">Create a new azure container registry instance</a></li><li><a href="#register-the-azure-container-registry-instance-in-azure-devops">Register the azure container registry instance in Azure DevOps</a></li><li><a href="#create-a-pipeline-definition-to-build-and-push-a-docker-image">Create a pipeline definition to build and push a docker image</a></li><li><a href="#add-the-azure-devops-git-repo-as-a-remote-and-push-the-code">Add the Azure DevOps GIT repo as a remote and push the code</a></li></ol><p>Let's start with creating a new azure container registry instance.</p><h3 id="create-a-new-azure-container-registry-instance">Create a new azure container registry instance</h3><p>If you want to publish container images from your build you're going to need to have push access to a docker registry. Typically, you'll want a private registry in your organization when you're working for a customer. </p><p>To create a new azure container registry instance, execute the following command in PowerShell or a similar terminal:</p><figure class="kg-card kg-code-card"><pre><code>az group create -n MyMicroServices -l westeurope
az acr create -n mymicroserviceregistry -g MyMicroServices --sku basic</code></pre><figcaption>Commands to create a new registry</figcaption></figure><p>This code performs the following steps:</p><ol><li>First, we create a new resource group in west-europe with the name <code>MyMicroServices</code></li><li>Next, we create a new container registry in the resource group that we just created.</li></ol><p>It will take a few minutes to complete the steps. After you've completed the steps, we're ready to register the container instance in Azure DevOps.</p><h3 id="register-the-azure-container-registry-instance-in-azure-devops">Register the azure container registry instance in Azure DevOps</h3><p>To register a container registry in Azure DevOps, go to the project settings of the project you want to  register the container registry in.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="/content/images/2019/11/image.png" class="kg-image"><figcaption>Navigating to the project settings</figcaption></figure><p>Next, select <code>Service Connections</code> under the <code>Pipelines</code> section. This will open up the service connection settings.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="/content/images/2019/11/image-1.png" class="kg-image"><figcaption>Service connection settings</figcaption></figure><p>Now, add a new service connection of type <code>Docker registry</code>. This will open up the docker registry settings panel.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="/content/images/2019/11/image-2.png" class="kg-image"><figcaption>Add docker registry service connection settings</figcaption></figure><p>Choose <code>Azure Container Registry</code> as the type of registry to connect to. Next, give the registry connection a memorable name.  Then, select your subscription and the registry you just created. Finally, click OK to register it. </p><p><strong>Note:</strong> Azure DevOps may ask you to login to your Azure Subscription before it can find the container registry. Follow the steps on the screen to do so.</p><p>Now that we have the container registry, let's build a pipeline that will build the docker image and publish it to the container registry.</p><h3 id="create-a-pipeline-definition-to-build-and-push-a-docker-image">Create a pipeline definition to build and push a docker image</h3><p>When you've used Azure DevOps before, back when it was called Visual Studio Team Services, you're probably familiar with the graphical editor for the build pipeline. You no longer need to do this. You can create Azure DevOps pipelines inside your project as a YAML file. </p><p>Add a new file called <code>azure-pipelines.yml</code> to the root of your project, and add the following contents to this file:</p><pre><code>trigger:
  - master

pool:
  vmImage: "ubuntu-16.04"
  
variables:
  registryConnection: myRegistryConnection
  imageName: mymicroservice

steps:
  - task: Docker@2
    displayName: "Build image"
    inputs:
      repository: $(imageName)
      containerRegistry: $(registryConnection)
      command: buildAndPush
      Dockerfile: Dockerfile
      tags: $(Build.BuildNumber)
</code></pre><p>It performs the following steps:</p><ol><li>First, we define the trigger for the build. Whenever something is pushed to master, a new build is started.</li><li>Next, we'll specify that the build should run on a hosted Linux agent.</li><li>Then, we define a build step specifying that we want to build a docker image and push it to a container registry. </li></ol><p>The build will use the variables from the variables section to specify the name of the image to build and the container registry connection to push to. Make sure you modify those to the values you've used earlier to create the image and registry.</p><p>Make sure to commit your changes to your local repository. Use the following commands to do so:</p><pre><code>git add .
git commit -m "Add build pipeline definition"</code></pre><p>Now that you've set up the build pipeline definition, let's push it to Azure DevOps.</p><h3 id="add-the-azure-devops-git-repo-as-a-remote-and-push-the-code">Add the Azure DevOps GIT repo as a remote and push the code</h3><p>To push the code to Azure DevOps, you'll need to know the URL of the repository. You can find this URL by navigating to the repos section of your DevOps project. You'll get to see the following page when the repo is still empty:</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="/content/images/2019/11/image-3.png" class="kg-image"><figcaption>Azure DevOps - Empty repo</figcaption></figure><p>Copy the Clone URL at the top of the page and use it in the following command to add the repo as the remote for the GIT repository on your machine:</p><pre><code>git remote add origin &lt;url&gt;</code></pre><p>Replace the <code>&lt;url&gt;</code> token with the URL you copied from your DevOps project.</p><p>Now, push the code to the new remote using the following command:</p><pre><code>git push -u origin master </code></pre><p>This command will not only push the code to the DevOps project. It will also make sure that, it will pushed there automatically, next time you invoke <code>git push</code>.</p><p>Take a moment to enjoy the results. After you've done that for a minute, navigate to the pipelines section in Azure DevOps and notice how it automatically picked up your build!</p><p>Now that you have a running build, let's take a look at setting up a  release pipeline for it.</p><h2 id="setting-up-a-release-pipeline">Setting up a release pipeline</h2><p>In the previous steps we've created a new micro-service, defined a docker image for it, and pushed it to a registry from our automated build. In this section we're going to take a look at building a release pipeline for our micro-service.</p><p>The goal of our release pipeline is to release the micro-service that we've created to a kubernetes cluster. We're going to have to complete the following steps to do so:</p><ul><li><a href="#create-a-new-kubernetes-cluster">Create a new kubernetes cluster</a></li><li><a href="#register-the-kubernetes-cluster-with-azure-devops">Register the kubernetes cluster with Azure DevOps</a></li><li><a href="#create-kubernetes-manifests-for-the-micro-service">Create kubernetes manifests for the micro-service</a></li><li><a href="#modify-the-build-to-publish-the-kubernetes-manifests">Modify the build to publish the kubernetes manifests</a></li><li><a href="#create-a-release-pipeline">Create a release pipeline</a></li></ul><p>Let's start by creating a new kubernetes cluster in Azure.</p><h3 id="create-a-new-kubernetes-cluster">Create a new kubernetes cluster</h3><p>Before we can publish our micro-service to production we need a spot for it to run. This will be a kubernetes cluster in Azure. </p><p>To create a new kubernetes cluster, we first need to enable the AKS preview extension on the Azure CLI. Use the following command to do so:</p><pre><code>az extension add --name aks-preview</code></pre><p>Once this command is finished, create a new cluster using the following command:</p><pre><code>az aks create -g MyMicroServices -n microservicedevcluster --node-count 3 --generate-ssh-keys --attach-acr mymicroserviceregistry</code></pre><p>This command creates a new cluster in the <code>MyMicroServices</code> group. It will automatically attach the container registry to the cluster so you can pull images from this registry into the kubernetes cluster.</p><p><strong>Note:</strong> The command will take a long time to complete, depending on how many nodes you've selected to use. Typically it will take up to 20 minutes to complete.</p><p>Once you've setup the cluster, let's register it with Azure DevOps.</p><h3 id="register-the-kubernetes-cluster-with-azure-devops">Register the kubernetes cluster with Azure DevOps</h3><p>To deploy to the new kubernetes cluster, we need to register it in Azure DevOps. Navigate to the project settings of your Azure DevOps project and add a new Service Connection for the cluster.</p><figure class="kg-card kg-image-card"><img src="/content/images/2019/11/image-4.png" class="kg-image"></figure><p>First, select the Azure Subscription as the authentication. Next, give the connection a memorable name. Then, choose the subscription to connect to. After that, select the cluster from the list of available clusters. Finally, click OK to register the cluster.</p><p>Now that you've got the cluster registered, let's setup the kubernetes manifests for the service.</p><h3 id="create-kubernetes-manifests-for-the-micro-service">Create kubernetes manifests for the micro-service</h3><p>To deploy our micro-service to kubernetes we're going to define two manifests. One for  the deployment of the service and one for the service definition so the service is accessible.</p><p>The deployment manifests creates/updates a scalable set of pods for your application which will run the container image that you've created. </p><p>Create a new folder in your project with the name <code>manifests</code> and add a new file to it called <code>deployment.yml</code>. Add the following contents to this file:</p><pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: mymicroservice
  labels:
    app: mymicroservice
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mymicroservice
  template:
    metadata:
      labels:
        app: mymicroservice
    spec:
      containers:
        - name: search
          image: mymicroserviceregistry.azurecr.io/mymicroservice
          ports:
            - containerPort: 80
              name: http
          imagePullPolicy: Always
</code></pre><p>This deployment manifest file our micro-service to the cluster. We're asking Kubernetes to deploy just 1 copy of the micro-service using the image that we've pushed to the private docker registry.</p><p>Notice, that we haven't specified the version of the image to deploy. We'll let Azure DevOps figure that out for us.</p><p>After we've created the deployment manifest, we need to define the service manifest.</p><p>The service manifest is used to expose your application within the cluster to other micro-services. It routes requests to a well-known endpoint and port to one of the pods that are deployed for your micro-service.</p><p>Create a new file <code>service.yml</code> in the <code>manifests</code> folder and add the following contents to it:</p><pre><code>apiVersion: v1
kind: Service
metadata:
  name: mymicroservice
spec:
  selector:
    app: mymicroservice
  ports:
    - port: 80
      targetPort: 80</code></pre><p>This service manifests, routes all requests going to the <code>mymicroservice</code> based on the selector that we've specified in the service definition.</p><p>Now that we have the manifests, we can move on to publishing from our build.</p><h3 id="modify-the-build-to-publish-the-kubernetes-manifests">Modify the build to publish the kubernetes manifests</h3><p>In the previous section, <a href="#setting-up-a-build-pipeline">Setting up a build pipeline</a>, we've set up an initial build definition for our micro-service. This build definition doesn't include a way to publish the Kubernetes manifests.  So we need to change it.</p><p>Open up the <code>azure-pipelines.yml</code> file in the root of the project and add the following lines to the file:</p><pre><code>- task: PublishBuildArtifacts@1
  displayName: "Publish artifacts"
    inputs:
      pathtoPublish: manifests
      artifactName: "manifests"
      publishLocation: "Container"</code></pre><p>This task takes care of copying the contents of the manifests folder and publishing them as an artifact of the build.</p><p>Commit the changes and push them to Azure DevOps using the following commands:</p><pre><code>git commit -am "Add publish artifacts step"
git push</code></pre><p>A new build is automatically started for you. As soon as it's finished you will find a new artifact on the build status page, called manifests.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="/content/images/2019/11/image-5.png" class="kg-image"><figcaption>Build artifacts</figcaption></figure><p>After we've published the manifests in the build, we need to setup a release pipeline to deploy the micro-service in Kubernetes.</p><h3 id="create-a-release-pipeline">Create a release pipeline</h3><p>In the previous section we modified the build pipeline to produce an artifact containing the manifests. In this section, we're going to use the manifests from the build to deploy the micro-service to Kubernetes.</p><p>First, we need to create a new release pipeline. Navigate to the Pipelines &gt; Releases section in Azure DevOps and click the New button to create a new release pipeline.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="/content/images/2019/11/image-6.png" class="kg-image"><figcaption>Create a new release pipeline</figcaption></figure><p>You'll get a list of templates for the new release pipeline. Scroll down to the bottom and click Apply next to the <em>Empty job</em> template.</p><p>Once the template is applied, you will see the following screen layout.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="/content/images/2019/11/image-7.png" class="kg-image"><figcaption>Created release pipeline</figcaption></figure><p>On the left, you'll find the artifacts. These artifacts can be released to production. Next to the artifacts area, you can find the first stage in the release pipeline. You can rename this stage in the panel to the right. </p><p>Click on the <em>Add an artifact</em> button and select the build you want to publish from. Give the new artifact a name and click <em>Add</em> to add the artifact to the pipeline.</p><p>Next, click the link below the name of the stage in the stage symbol on screen. This will open up the job view.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="/content/images/2019/11/image-8.png" class="kg-image"><figcaption>Job view</figcaption></figure><p>In this screen we can set up the steps needed to deploy to Kubernetes. Add a new task to the Agent job by clicking on the + button.</p><p>Search for <em>kubernetes</em> in the search box and select the <em>Deploy to kubernetes</em> task. Click the <em>Add</em> button to add it to the list of tasks.</p><p>Then, click on the task in the release pipeline to edit its properties. You'll need to configure the following properties:</p><ul><li>Kubernetes service connection: Select the connection you registered earlier</li><li>Namespace: default</li><li>Manifests: Browse to the deployment.yml file in the manifests artifact</li><li>Containers: Enter the name of the image you want to deploy. In our case: <code>mymicroserviceregistry.azurecr.io/mymicroservice</code></li></ul><p>Repeat the same steps for the <code>service.yml</code> file to deploy the service definition to Kubernetes as well.</p><p>Now that you have the pipeline set up, let's configure it so a new release is started when the build finishes. </p><p>Navigate to the <em>Pipeline</em> tab and click the lightning symbol next to the artifact of the release pipeline. </p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="/content/images/2019/11/image-9.png" class="kg-image"><figcaption>Release triggers</figcaption></figure><p>Click the slider at the top of the properties panel so the continuous deployment trigger is enabled. You can, optionally, specify for which branch the deployment should trigger. </p><p>Save the pipeline and queue a new release to deploy your micro-service. You can view the results by executing the following commands:</p><pre><code>az aks get-credentials -n &lt;cluster-name&gt; -g &lt;cluster-group&gt;
kubectl get pods
kubectl get services</code></pre><p>The first line retrieves the credentials for kubectl to access the AKS cluster. You will need to modify this command to point to the right cluster in the right resource group.</p><p>The next lines retrieve the pods and services. The result should be a list of pods and services that were deployed to the cluster from the release pipeline.</p><h2 id="summary">Summary</h2><p>And that's what it takes to deploy a micro-service to kubernetes from Azure DevOps. </p><p>First, we looked at how to package .NET micro-services using a multi-stage docker file. </p><p>Next, we looked at building docker images from a build pipeline. Thanks to the Docker task it's a breeze to build a docker image.</p><p>Finally, we used the Kubernetes tasks to deploy the micro-services. The Kubernetes task will be of great help, since you don't need to think about version numbers. The version is automatically picked up by the release pipeline and injected where needed.</p><p>I hope you liked reading this tutorial. Let me know what you think on twitter! <a href="https://twitter.com/willem_meints">@willem_meints</a></p>
